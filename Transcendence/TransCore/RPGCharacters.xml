<?xml version="1.0" encoding="utf-8"?>

<TranscendenceModule>

<!-- RPG Characters (NPCs)======================================================

	Station characters:
		Assign random character names to specific station roles (station master,
		bartender etc.) using rpgCharacterRandom. These can be used to make minor
		customisations to mission text. Example - Korolov Shipping

		Add variant property "rpgCharacter.assistantDirector" to station:
			(rpgCharacterRandom gSource "x +assistantDirector; +korolov;" 'assistantDirector)

		This will find suitable types with matching attributes and Static data "CharacterTable"

		Implementation

		Static Data on character types: CharacterTable
		Alternative property rpg.characterTable is not fully implemented

		Global data on space object type:
			rpgCharacterList.<role>
			rpgCharacterNext.<role>

		Property on space object: rpgCharacter.<role>


	Mission giver characters:
		Variant property set on mission. Used to provide alternative mission text.
		Example - Commonwealth Mining, Commonwealth Volunteer missions

		Note - current examples used in Eridani with custom tlisp calls to
		typTranslate. But these could probably be reworked to fit the station
		character system and use rpgCharacterTranslate


	Major characters:
		Typically used by characters which have an associated ship and can assign
		missions across different systems. Example: Benedict, Kate Morgental

		Character class should inherit from baStdNPCBase and override the definition
		properties as appropriate.

		Note legacy character types defined with static data used the following fields:

		Static Data:
			MissionAttribute
			Name
			Sovereign

		Dynamic:
			firstPlayerMeetingTime
			latestPlayerMeetingTime
			lastNodeID
			lastShipClass
			objID_<unid>
			lastOrders
			lastSystemPos
			lastKnown
			playerRel
			status
			screenData

		Events:
			OnCharacterCanBeMet
-->

	<Type UNID="&baStdNPCBase;">
		<Properties>
			<Definition id="core.namePattern">": Generic NPC"</Definition>
			<Definition id="char.missionAttribute">"undefined"</Definition>
			<Definition id="char.sovereign">&svNeutral;</Definition>

			<!-- char.firstMeetingOn

				Tick of player's first meeting with character.
				Nil if the player has never met face to face.

				-->

			<Global id="char.firstMeetingOn"></Global>

			<!-- char.latestMeetingOn: Tick of most recent meeting with character -->

			<Global id="char.latestMeetingOn"></Global>

			<!-- char.status: used by alive and well checks -->

			<Global id="char.status"></Global>

			<!-- char.screenData

				This is a structure specifying the screen to show when the player
				interacts with the character. The struct has the following fields:

				screen: The screen to show
				pane: If non-Nil, the pane to navigate to
				data: If non-Nil, data to pass to the screen
				translateType: Used with translate ID. If both are non-Nil we call
				translateID: typTranslate on ehse arguments rather than passing pane/data

				If this value is Nil, then we look for missions tagged with
				character mission attribute (e.g., kateMorgentalMission).

				-->

			<Global id="char.screenData"></Global>

			<!-- char.scope

				Determines how long the NPC will remain in system

				Nil: Until player leaves the system
				mission: Until current mission is complete
				ongoing: Until explicitly removed, or created elsewhere

				-->

			<Global id="char.scope"></Global>

			<Global id="char.missionID"></Global>
			<DynamicGlobal id="char.mission">
				(and (typ@ gType 'char.missionID) (objGetObjByID (typ@ gType 'char.missionID)))
			</DynamicGlobal>

			<!-- char.ship*: stores data for NPC's current ship -->

			<Global id="char.shipClass"></Global>
			<Global id="char.shipNodeID"></Global>
			<Global id="char.shipKnown"></Global>
			<Global id="char.shipOrders"></Global>
			<Global id="char.shipPos"></Global>

			<!-- char.objectIDs

				Struct of {UNID: objID} for all ships used by NPC.
				If Nil, then no ship has been created yet.

				-->

			<Global id="char.objectIDs"></Global>

			<!-- char.version

				Internal variable to track which version of the character type we have
				Nil:	legacy type using type data
				1:		Initial property implementation

				-->
			<Global id="char.version">1</Global>

			<!-- char.objID: The objID of character's current ship -->

			<DynamicGlobal id="char.objID">
				(@ (typ@ gType 'char.objectIDs) (typ@ gType 'char.shipClass))
			</DynamicGlobal>
		</Properties>

		<Events>
			<OnCharacterCanBeMet>
				True
			</OnCharacterCanBeMet>

			<OnGlobalSystemStopped>
				(rpgCharacterAscend gType)
			</OnGlobalSystemStopped>

			<OnGlobalSystemStarted>
				(if (rpgCharacterInSystem gType)
					(rpgCharacterDescend gType)
					)
			</OnGlobalSystemStarted>

			<OnGlobalUniverseLoad>
				(rpgCharacterUpdateVersion gType)
			</OnGlobalUniverseLoad>
		</Events>
	</Type>


<!-- CHARACTER SCREEN ==========================================================

	USAGE

	The object (generally a ship) with this screen must set the character 
	parameter on the class.

	The object must also define the following language elements:

		core.firstIntro
		core.intro
		core.noMissions

	The character type must define the following static data elements:

		MissionAttribute: A string representing the attribute to use for all 
				missions that may be assigned by the character.

	The character type must define the following events:

		OnCharacterCanBeMet: If handled, the event may return True to indicate
				that the meeting should continue. Or the event may return a
				string to display declining the meeting.

-->

	<DockScreen UNID="&dsRPGCharacterDefault;"
			inherit=			"&dsDockScreenBase;"
			>
		<OnScreenInit>
			;	Make sure the player is allowed to talk to this character.

			(block (explanation)
				(switch
					;	If Nil, then the event is not handled so we continue meeting.

					(not (setq explanation (typFireObjEvent (objGetProperty gSource 'character) gSource 'OnCharacterCanBeMet)))
						True

					;	If True, then we are allowed to meet and continue.

					(eq explanation True)
						True

					;	Otherwise, we expect an explanation string.

					(scrShowScreen gScreen &dsRPGMessage; {
						desc: explanation
						nextScreen: 'forceUndock
						})
					)
				)
		</OnScreenInit>

		<Panes>
			<Default>
				<OnPaneInit>
					(block (
						(charType (obj@ gSource 'character))
						(firstMeeting (not (or (typ@ charType 'char.firstMeetingOn) (typGetData charType 'firstPlayerMeetingTime))))
						)

						(rpgPagePaneInit gScreen 

							(or (scrTranslate gScreen (if firstMeeting 'core.firstIntro 'core.intro)) 
								(scrTranslate gScreen (if firstMeeting 'FirstMeetingIntro 'MeetingIntro))
								)

							{
							actionDoneID: 'actionContinue

							onExitPane: (lambda (theScreen pageDesc options)
								(block (
									(charType (obj@ gSource 'character))
									(screenData (or (typ@ charType 'char.screenData) (typGetData charType 'screenData)))
									)

									;	We've met character

									(rpgCharacterSetMeeting charType)
							
									;	Next screen
									
									(switch
										;	If we have a translateType and translateID, then translate
										;	[We need to do this sometimes if the data that we're passing has
										;	non-serializable objects.]
										(@ screenData 'translateID)
											(scrShowScreen
												gScreen
												(@ screenData 'screen)
												(typTranslate (@ screenData 'translateType) (@ screenData 'translateID))
												)
									
										;	Otherwise, we expect a screen.
										screenData
											(scrShowScreen 
												gScreen 
												(@ screenData 'screen) 
												(@ screenData 'pane) 
												(@ screenData 'data)
												)

										;	If no set screen, look for missions.

										(rpgCharacterShowMissionScreen gSource { 
											nextScreen: 'forceUndock
											})
										)
									)
								)
							})
						)
				</OnPaneInit>
			</Default>
		</Panes>
	</DockScreen>

<!-- GLOBAL FUNCTIONS ==========================================================

	USAGE

	These functions use the properties defined in the NPC base class. See
	baStdNPCBase above for further details.

	lastNodeID: Character's last known position. Nil means unknown.

	lastSystemPos: Character's last known position in the lastNodeID system.

	playerRel: If Nil, character has never met the player. Positive numbers mean that
			character likes/trusts/respects the player. Negative numbers mean the
			opposite.

-->

	<Globals>
		(block Nil
			(setq rpgCharacterUpdateVersion (lambda (charType)
				"PRIVATE: Used to migrate from legacy data to properties"
				(switch
					;	Already using properties
					(typ@ charType 'char.version)
						Nil

					;	Need to transition from type data
					(block (
						(transition (lambda (oldVar newVar)
							(block ()
								(typSet@ charType newVar (typGetData charType oldVar))
								(typSetData charType oldVar Nil)
								)
							))

						(shipClassValue (typGetData charType 'lastShipClass))
						(shipIDVar (cat 'objID_ (int shipClassValue)))
						(objID (typGetData charType shipIDVar))
						)
						(dbgOutput "Updating " (typGetName charType) " from typData")

						(transition 'firstPlayerMeetingTime 'char.firstMeetingOn)
						(transition 'latestPlayerMeetingTime 'char.latestMeetingOn)
						(transition 'lastNodeID 'char.shipNodeID)
						(transition 'lastShipClass 'char.shipClass)
						(transition 'lastOrders 'char.shipOrders)
						(transition 'lastSystemPos 'char.shipPos)
						(transition 'lastKnown 'char.shipKnown)
						(transition 'status 'char.status)
						(transition 'screenData 'char.screenData)

						;	Can only transition current ship objID
						(typSet@ charType 'char.objectIDs (struct shipClassValue objID))
						(typSetData charType shipIDVar Nil)


						(typSet@ charType 'char.version 1)
						)
					)
				))

			(setq rpgCharacterAscend (lambda (charType)
				(block (
					(lastNodeID (or (typ@ charType 'char.shipNodeID) (typGetData charType 'lastNodeID)))

					shipClassValue
					objID
					shipObj
					)

					(switch
						;	If lastNodeID doesn't equal this system, then nothing to do.
						
						(and lastNodeID (!= lastNodeID (sysGetNode)))
							Nil	;(dbgOutput (sysGetNode) ": lastNodeID = " lastNodeID)
							
						;	If no last ship class then we can't do anything because we don't know
						;	how to find the object ID.
						
						(not (setq shipClassValue (or (typ@ charType 'char.shipClass) (typGetData charType 'lastShipClass))))
							Nil
							
						;	Get the object ID from the character type and ship class
						
						(not (setq objID (or
								(typ@ charType 'char.objID)
								(typGetData charType (cat 'objID_ (int shipClassValue)))
								)))
							Nil	;(dbgOutput (sysGetNode) ": Can't find object ID for " charType)
							
						;	If no ship, then nothing to do
						
						(not (setq shipObj (objGetObjByID objID)))
							;	NOTE - this probably means the ship was destroyed
							Nil	;(dbgOutput (sysGetNode) ": Can't find ship object")

						;	If ship has already ascended it likely left via a gate, or mission
						;	manually removed it from system. Eitherway we clear the last node

						(obj@ shipObj 'ascended)
							(typSet@ charType 'char.shipNodeID Nil)

						;	If the ship is currently a player wingman, then do not ascend;
						;	the ship will follow the player.

						(obj@ shipObj 'playerWingman)
							Nil
							
						;	Otherwise, ascend the object
						
						(block (orders)
							;	Save the current order stack
							(for i 1 (shpGetOrderCount shipObj)
								(block Nil
									(lnkAppend orders
										{
											desc: (shpGetOrderDesc shipObj)
											objID: (objGetID (shpGetOrderTarget shipObj))
											}
										)
									(shpCancelOrder shipObj)
									)
								)
							(if (typHasProperty charType 'char.shipClass)
								(block Nil
									(typSet@ charType 'char.shipOrders orders)
									(typSet@ charType 'char.shipPos (objGetPos shipObj))
									(typSet@ charType 'char.shipKnown (obj@ shipObj 'known))
									)
								(block Nil
									(typSetData charType 'lastOrders orders)
									(typSetData charType 'lastSystemPos (objGetPos shipObj))
									(typSetData charType 'lastKnown (obj@ shipObj 'known))
									)
								)
							(sysAscendObject shipObj)
							; (dbgOutput (sysGetNode) ": Ship ascended: " (objGetID shipObj))
							)
						)
					)
				))

			(setq rpgCharacterInSystem (lambda (charType)
				"Check if the given character should be in the current system"

				; This function is intended to be used with in the character's
				; OnGlobalSystemStarted event to determine if we should automatically
				; descend the character on system start. It could also be used from
				; Mission OnGlobalSystemStarted events to check if the NPC is already
				; present or we need to call rpgCharacterCreateShip

				(switch
					(not (typ@ charType 'char.scope))
						Nil

					;	If not in the right node, then nothing to do
					(!= (sysGetNode) (typ@ charType 'char.shipNodeID))
						Nil

					;	Check if we have a valid ship object available
					(not (objGetObjByID (typ@ charType 'char.objID)))
						Nil

					;	If scope is ongoing try to restore ship
					(= (typ@ charType 'char.scope) 'ongoing)
						True

					;	Anything else we need to check mission scope
					(block (
						(missionObj (typ@ charType 'char.mission))
						)
						(switch
							(not missionObj)
								Nil

							;	Assume we need to remain until player has been debriefed
							(msn@ missionObj 'isDebriefed)
								Nil

							True
							)
						)
					)
				))

			(setq rpgCharacterDescend (lambda (charType)

				; This function descends the character's current ship. It is intended to be used
				; by the OnGlobalSystemStarted event so we can resume NPCs if the player leaves
				; and returns to a given system.

				(block (
					(objID (typ@ charType 'char.objID))
					(shipObj (objGetObjByID objID))
					)
					(switch
						(not shipObj)
							Nil

						(not (obj@ shipObj 'ascended))
							Nil

						(block Nil
							(setq shipObj (sysDescendObject objID (typ@ charType 'char.shipPos)))
							(enum (typ@ charType 'char.shipOrders) order
								(block (cmd)
									(setq cmd (append shipObj (@ order 'desc)))
									(if (@ order 'objID) (set@ cmd 2 (objGetObjByID (@ order 'objID))))
									(apply shpOrder cmd)
									)
								)
							)
						)
					)
				))

			(setq rpgCharacterChangeRel (lambda (charType event)
			
				; This function changes the character's relationship with the
				; player based on something the player did.
				;
				; The following events are valid:
				;
				; 'betrayal: The player betrayed the character in a fundamental
				;		way, generally by agreeing to pursuing a goal and then
				;		actively opposing that goal.
				;
				; 'opposition: The player acted against a major character goal,
				;		but did not necessarily betray the character.
				;
				; 'failure: The player failed in a task that the character was
				;		counting on, generally through incompetence rather than
				;		enmity.
				;
				; 'aid: The player helped the character in pursuit of a major
				;		goal.
				;
				; 'rescue: The player risked his/her life to save the character
				;		(or to save the life of someone the character cares
				;		about).
				
				(block (
					(curRel (or (typGetData charType 'playerRel) 'notSet))
					)
					
					(switch
						
						(eq event 'betrayal)
							(typSetData charType 'playerRel
								(@ {
									notSet: 'nemesis			;	First impression count for a lot.
									nemesis: 'nemesis
									dislikes: 'nemesis
									neutral: 'dislikes
									likes: 'neutral
									loyalty: 'nemesis			;	Betrayal hurts most if you feel loyal to someone.
									}
									curRel
									))
								
						(eq event 'opposition)
							(typSetData charType 'playerRel
								(@ {
									notSet: 'dislikes
									nemesis: 'nemesis
									dislikes: 'dislikes
									neutral: 'dislikes
									likes: 'neutral
									loyalty: (random (list		;	60% of the time we stay loyal
										'nemesis
										'dislikes
										'neutral
										'likes
										'loyalty
										'loyalty
										'loyalty
										'loyalty
										'loyalty
										'loyalty
										))
									}
									curRel
									))
						
						(eq event 'failure)
							(typSetData charType 'playerRel
								(@ {
									notSet: 'dislikes
									nemesis: 'nemesis
									dislikes: 'dislikes
									neutral: 'dislikes
									likes: 'neutral
									loyalty: 'loyalty
									}
									curRel
									))
								
						(eq event 'aid)
							(typSetData charType 'playerRel
								(@ {
									notSet: 'likes
									nemesis: 'nemesis
									dislikes: (if (leq (random 1 100) 50) 'neutral 'dislikes)
									neutral: 'likes
									likes: (if (leq (random 1 100) 20) 'loyalty 'likes)
									loyalty: 'loyalty
									}
									curRel
									))
								
						(eq event 'rescue)
							(typSetData charType 'playerRel
								(@ {
									notSet: 'loyalty
									nemesis: 'loyalty
									dislikes: 'likes
									neutral: 'likes
									likes: 'loyalty
									loyalty: 'loyalty
									}
									curRel
									))
						)
					)
				))

			(setq rpgCharacterCreateShip (lambda (charType shipClassUNID pos options)

				; This function creates a ship for the given character.
				; shipClassUNID and pos are optional when descending an existing ship.
				; options:
				;	setKnown: set known property on ship object
				;	repairAll: repair all damage
				;	mission: missionObj that created the ship. Sets scope to mission
				;	remain: if non-Nil we set scope to ongoing

				(block (
					;	We store a ship ID for every unique ship class. Some characters
					;	use multiple ships.
					
					(shipClassValue (or shipClassUNID (typ@ charType 'char.shipClass) (typGetData charType 'lastShipClass)))
					(shipIDVar (cat 'objID_ (int shipClassValue)))
					(objID (or (typ@ charType 'char.objID) (typGetData charType shipIDVar)))
					
					(shipObj (objGetObjByID objID))

					;	Do we need to use legacy typData
					(useData (not (typHasProperty charType 'char.version)))
					)

					;	If we have an objID but can't find the object, then report error
					(if (and objID (not shipObj))
						(printTo 'log "ERROR: Unable to find object ID: " objID ".")
						)

					(switch
						;	If ship for character does not exist, then we need to 
						;	create him.

						(and useData (not shipObj))
 							(block Nil
								(setq shipObj (sysCreateShip shipClassValue pos (typGetStaticData charType 'Sovereign)))
								(objSetProperty shipObj 'known (@ options 'setKnown))
								(typSetData charType 'lastNodeID (sysGetNode))
								(typSetData charType 'lastShipClass shipClassValue)
								(typSetData charType 'lastOrders Nil)
								(typSetData charType shipIDVar (objGetId shipObj))
								(typSetData charType 'screenData Nil)
								
								; (dbgOutput (sysGetNode) ": No obj ID; creating ship: " (objGetID shipObj))
								)

						(not shipObj)
							(block Nil
								(setq shipObj (sysCreateShip shipClassValue pos (typ@ charType 'char.sovereign)))
								(objSet@ shipObj 'known (@ options 'setKnown))
								(typSet@ charType 'char.shipNodeID (sysGetNode))
								(typSet@ charType 'char.shipClass shipClassValue)
								(typSet@ charType 'char.shipOrders Nil)
								(typSet@ charType 'char.objectIDs (struct
										(typ@ charType 'char.objectIDs)
										shipClassValue
										(objGetId shipObj)
									))
								(typSet@ charType 'screenData Nil)
								)

						;	If the object is ascended, we descend it.

						(obj@ shipObj 'ascended)
							(block (isKnown lastOrders)

								;	If ship has been here all along, then just place him in the
								;	original position.

								(if (= (sysGetNode) (or (typ@ charType 'char.shipNodeID) (typGetData charType 'lastNodeID)))
									(block Nil
										(setq pos (or (typ@ charType 'char.shipPos) (typGetData charType 'lastSystemPos)))
										(setq isKnown (or (typ@ charType 'char.shipKnown) (typGetData charType 'lastKnown)))
										(setq lastOrders (or (typ@ charType 'char.shipOrders) (typSetData charType 'lastOrders)))
										)
									
									;	If he was not here last, then we honor options

									(block Nil
										(setq isKnown (@ options 'setKnown))
										(typSetData charType 'lastOrders Nil)
										)
									)

								;	Descend him back to the system

								(setq shipObj (sysDescendObject objID pos))
								; (dbgOutput (sysGetNode) ": Descending ship: " (objGetID shipObj))
								
								;	If we could not descend, then something happened. Just create
								;	the character here.

								(if (not shipObj)
									(block Nil
										(printTo 'log "ERROR: Unable to descend object ID: " objID ".")
										(setq shipObj (sysCreateShip shipClassValue pos (or
												(typ@ charType 'char.sovereign)
												(typGetStaticData charType 'Sovereign)
											)))
										(if useData
											(typSetData charType shipIDVar (objGetID shipObj))
											(typSet@ charType 'char.objectIDs (set@
													(typ@ charType 'char.objectIDs)
													shipClassValue
													(objGetId shipObj)
												))
											)
										)
									)

								;	Remember where we are
								
								(if useData
									(block Nil
										(typSetData charType 'lastNodeID (sysGetNode))
										(typSetData charType 'lastShipClass shipClassValue)
										(typSetData charType 'screenData Nil)
										)
									(block Nil
										(typSet@ charType 'char.shipNodeID (sysGetNode))
										(typSet@ charType 'char.shipClass shipClassValue)
										(typSet@ charType 'char.screenData Nil)
										)
									)
								
								;	Set known
								
								(objSet@ shipObj 'known isKnown)
								)
							
						;	Otherwise, we assume shipObj is valid

						)

					;	We always reenable docking, in case some previous code disabled it.

					(if shipObj
						(objSet@ shipObj 'dockingEnabled True)
						)

					;	If requested, we repair all damage
					
					(if (@ options 'repairAll)
						(block Nil
							(intArmorRepairAll shipObj)
							(objSet@ shipObj 'interiorHP (obj@ shipObj 'maxInteriorHP))
							)
						)

					;	If we were created by a mission, then store ID and set scope

					(if (@ options 'mission)
						(block Nil
							(typSet@ charType 'char.missionID (msn@ (@ options 'mission) 'id))
							(typSet@ charType 'char.scope 'mission)
						))

					(if (@ options 'remain)
						(typSet@ charType 'char.scope 'ongoing)
						)

					;	Return character's ship

					shipObj
					)
				))

			(setq rpgCharacterGetQuickRel (lambda (charType)

				; This function returns the given character's relationship with 
				; the player. The function returns one of the following values:
				;
				; Nil: The player and the character have never met.
				;
				; 'favorable: The character is favorable towards the player.
				;		(i.e., rel is neutral, likes, or loyalty)
				;
				; 'unfavorable: The character is unfavorable towards the player.
				;		(i.e., rel is dislikes or nemesis)

				(block (rel)
					(setq rel (rpgCharacterGetRel charType))

					(switch
						(not (or (typ@ charType 'char.firstMeetingOn) (typGetData charType 'firstPlayerMeetingTime)))
							Nil

						(or (eq rel 'nemesis)
								(eq rel 'dislikes))
							'unfavorable

						'favorable
						)
					)
				))

			(setq rpgCharacterGetRel (lambda (charType)
				
				; This function returns the given character's relationship with 
				; the player. The function returns one of the following values:
				;
				; Nil: The player and the character have never met (or the
				;		character has not yet formed an opinion).
				;
				; 'nemesis: The character hates the player.
				;
				; 'dislikes: The character dislikes the player, but not enough
				;		to actively work against her.
				;
				; 'neutral: The character does not have an opinion about the
				;		player.
				;
				; 'likes: The character generally likes the player, but is not
				;		necessarily a close friend.
				;
				; 'loyalty: The character feels loyalty and friendship for the
				;		player.
				
				(typGetData charType 'playerRel)
				))

			(setq rpgCharacterGetStatus (lambda (charType)
				(or (typ@ charType 'char.status) (typGetData charType 'status))
				))

			(setq rpgCharacterIsAliveAndWell (lambda (charType)
				(block (
					(status (rpgCharacterGetStatus charType))
					)
					(switch
						;	Dead means dead
						
						(or (= status 'dead) 
								(= status 'destroyed) 
								(= status 'destroyedByPlayer)
								)
							Nil
							
						;	Otherwise, we're alive and well
						
						True
						)
					)
				))

			(setq rpgCharacterSetMeeting (lambda (charType)
				(if (typHasProperty charType 'char.firstMeetingOn)
					(block ()
						(typSet@ charType 'char.latestMeetingOn (unvGetTick))
						(if (not (typ@ charType 'char.firstMeetingOn))
							(typSet@ charType 'char.firstMeetingOn (unvGetTick))
							)
						)
					(block ()
						(typSetData charType 'latestPlayerMeetingTime (unvGetTick))
						(if (not (typGetData charType 'firstPlayerMeetingTime))
							(typSetData charType 'firstPlayerMeetingTime (unvGetTick))
							)
						)
					)
				))

			(setq rpgCharacterSetScreen (lambda (charType screenData)
				(if (typHasProperty charType 'char.screenData)
					(typSet@ charType 'char.screenData screenData)
					(typSetData charType 'screenData screenData)
					)
				))

			(setq rpgCharacterSetMission (lambda (charType missionObj)
				"Sets current mission for given character. Maybe needed if ship was created before mission"
				(block (
					(missionID (msn@ missionObj 'id))
					)
					(typSet@ charType 'char.missionID missionID)
					(if missionID (typSet@ charType 'char.scope 'mission))
					)
				))

			(setq rpgCharacterSetStatus (lambda (charType newStatus)
			
				;	This function sets the status of the character. We support the following
				;	values:
				;
				;	Nil: Character is alive and well. No special status.
				;
				;	'dead: Character is permanently dead.

				(block (
					(oldStatus (rpgCharacterGetStatus charType))
					)
					(switch				
						;	If the character is permanently dead, then we can't 
						;	change the status.

						(= oldStatus 'dead)
							Nil

						;	Set the status
						(typSet@ charType 'char.status newStatus)
							True

						;	Legacy method
						(typSetData charType 'status newStatus)
						)
					)
				))

			(setq rpgCharacterShowMissionScreen (lambda (missionSource options)
				
				; This function is used to offer players a new mission.
				;
				; CONTEXT
				;
				; This must be called from inside a dock screen with a valid
				; gScreen parameter.
				;
				; PARAMETERS
				;
				; missionSource: The object that is giving the mission, generally
				;		character's ship.
				;
				; options:
				;		nextScreen: Screen to show when we're done.

				(block (
					(charType (obj@ missionSource 'character))
					(missionAttrib (cat " +" (or
								(typ@ charType 'char.missionAttribute)
								(typGetStaticData charType 'MissionAttribute)
								)
							";"))
					theMission newMissions
					)

					(switch

						;	If we have an active mission from this ship then we show it.

						(setq theMission (@ (msnFind missionSource (cat "aS" missionAttrib)) 0))
							(scrShowScreen gScreen &dsRPGMission;
								{
								missionObj: theMission
								nextScreen: (@ options 'nextScreen)
								})

						;	If we have an open mission available, return that

						(setq theMission (@ (msnFind missionSource (cat "oS" missionAttrib)) 0))
							(scrShowScreen gScreen &dsRPGMission;
								{
								missionObj: theMission
								nextScreen: (@ options 'nextScreen)
								})

						;	Make a list of available missions. 
						;	If we can't find anything, then we've got nothing.

						(not (setq newMissions (typFind (cat "n" missionAttrib))))
							(scrShowScreen gScreen &dsRPGMessage; {
								desc: (or (objTranslate missionSource 'core.noMissions) (objTranslate missionSource 'NoMissions))
								nextScreen: 'forceUndock
								})

						; Create a random mission from the list. If we succeed, then show the mission
						; screen.

						(setq theMission (msnCreate newMissions missionSource))
							(scrShowScreen gScreen &dsRPGMission;
								{
								missionObj: theMission
								nextScreen: (@ options 'nextScreen)
								})

						; Otherwise, nothing

						(scrShowScreen gScreen &dsRPGMessage; {
							desc: (or (objTranslate missionSource 'core.noMissions) (objTranslate missionSource 'NoMissions))
							nextScreen: 'forceUndock
							})
						)
					)
				))

			;	STATION CHARACTER PERSONAS -------------------------------------
			;
			;	This set of functions are used to manage random NPC on various
			;	stations. For example, these can be used to randomize a quest
			;	giver on a station.
			;
			;	USAGE
			;
			;	1.	Generate a CharacterTable in a StaticData block in one or 
			;		more types. A CharacterTable is a struct with one field per
			;		character ID. Each field is a struct containing information
			;		about the character.
			;
			;		For example:
			;
			;		{
			;			lukeSkywalker: {
			;				id: 'lukeSkywalker
			;				fullName: "Luke Skywalker"
			;				friendlyName: "Luke"
			;				formalName: "Skywalker"
			;				genome: 'human
			;				gender: 'genderMale
			;				notes: "Luke is a farmboy who dreams of being a pilot."
			;				}
			;			princessLeia: {
			;				id: 'princesLeia
			;				fullName: "Leia Organa"
			;				friendlyName: "Leia"
			;				formalName: "the Princess"
			;				genome: 'human
			;				gender: 'genderFemale
			;				notes: "Leia Organa is one of the leaders of the Rebellion."
			;				}
			;			}
			;
			;	2.	Call rpgCharacterAssignRandom in the OnCreate for a given
			;		station. You must call this once for each role used by the
			;		station. For example, if you have a station master and a
			;		bartender who both give out missions, you need two calls.
			;
			;	3.	Use rpgCharacterTranslate to get specific text for the 
			;		randomly chosen character.
			;
			;	4.	Use rpgCharacterGetInfo to get the full block of data for 
			;		the randomly chosen character.

			(setq rpgCharacterAssign (lambda (sourceObj role sourceType charID)
				"DEPRECATED: Assign sourceType charID in property instead"
				(block (
					(characterRole (or role "npc"))
					(characterVar (cat "rpgCharacter." characterRole))
					)
					(objSetData sourceObj characterVar (list sourceType charID))
					(if (not (rpgCharacterGetInfo sourceObj role))
						(error "No character found: " sourceType "/" charID)
						)
					)
				))

			(setq rpgCharacterAssignRandom (lambda (sourceObj criteria role)
				"DEPRECATED. Use rpgCharacterRandom in a variant property instead"

				;	This function assigns a random character to the given source object.
				;	It should be called once when the object is created.
				;
				;	Use rpgCharacterTranslate to get text for the character.

				(block (
					(characterRole (or role "npc"))
					(characterVar (cat "rpgCharacter." characterRole))

					(characterID (rpgCharacterRandom sourceObj criteria characterRole))
					)

					;	Store this character with the object.

					(objSetData sourceObj characterVar characterID)

					;	Done

					characterID
					)
				))

			(setq rpgCharacterGenerateList (lambda (criteria)
				
				;	This function returns a list of character identifiers for use
				;	by minor characters, such as station masters. The result consists
				;	of a list of character identifiers. Each identifier is a list
				;	with two values: an UNID and an ID within that type.
				;
				;	The order in the list is randomized.

				(shuffle
					(apply append
						(map (typFind criteria) 'excludeNil theType
							(block (
								(characterTable (typGetStaticData theType 'CharacterTable))
								)
								(if characterTable
									(map characterTable theCharacter
										(list theType (@ theCharacter 0))
										)

									;	If no character table, then the whole type is one
									;	character.

									(list (list theType Nil))
									)
								)
							)
						)
					)
				))

			(setq rpgCharacterGetInfo (lambda (sourceObj role defaultType)
				(block (
					(characterRole (or role "npc"))
					(characterVar (cat "rpgCharacter." characterRole))

					;	characterID is either a struct, which contains the 
					;	character info, or it is a list with two elements pointing
					;	to the character info. If the latter, the first element is
					;	the type containing the info and the second element is the
					;	id in the table.

					(characterID (or (objGetProperty sourceObj characterVar) (objGetData sourceObj characterVar)))
					)
					(switch
						;	If we have the character info, just return it, adding in a type
						;	so that we can translate text.

						(= (typeof characterID) 'struct)
							(struct characterID { sourceType:(objGetType sourceObj) })

						;	Otherwise, look up from the table

						(block (
							(theType (@ characterID 0))
							(theID (@ characterID 1))

							(characterTable (or (typGetProperty theType 'rpg.characterTable) (typGetStaticData theType 'CharacterTable)))
							)
							(switch
								(@ characterTable theID)
									(struct (@ characterTable theID) { sourceType:theType })

								defaultType
									(struct (@ (typGetStaticData defaultType 'CharacterTable) 'default) { sourceType:defaultType })
								)
							)
						)
					)
				))

			(setq rpgCharacterRandom (lambda (sourceObj criteria role)
				
				;	This function assigns a random character to the given source object.
				;	It should be called once when the object is created.
				;
				;	Use rpgCharacterTranslate to get text for the character.

				(block (
					(type (objGetType sourceObj))
					(characterRole (or role "npc"))

					(characterListVar (cat "rpgCharacterList." characterRole))
					(characterList (typGetData type characterListVar))

					(nextVar (cat "rpgCharacterNext." characterRole))
					(next (typGetData type nextVar))

					(characterVar (cat "rpgCharacter." characterRole))

					characterID
					)

					;	If we don't yet have a character list, then generate one.

					(if (not characterList)
						(block ()
							(setq characterList (rpgCharacterGenerateList criteria))
							(setq next 0)
							(typSetData type characterListVar characterList)
							(typSetData type nextVar 0)
							)
						)

					;	Pick a random character (the list has been shuffled, so we 
					;	just pick the next character on the list).

					(setq characterID (@ characterList (mod next (count characterList))))

					;	Next character

					(typIncData type nextVar)

					;	Done

					characterID
					)
				))

			(setq rpgCharacterTranslate (lambda (sourceObj role textID data)
				(block (
					(charInfo (rpgCharacterGetInfo sourceObj role))
					)
					(typTranslate (@ charInfo 'sourceType) (cat (@ charInfo 'id) "." textID) data)
					)
				))
			)
	</Globals>

</TranscendenceModule>
