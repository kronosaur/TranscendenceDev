<?xml version="1.0" encoding="utf-8"?>

<TranscendenceModule>

<!-- MISSIONS -->

	<!-- Component Reminder ====================================================

	This is a template for crafting reminder missions (e.g. Tinker recipe).

	Missions should be created by passing a fabInfo structure as gData


	======================================================================== -->
	
	<MissionType UNID="&baComponentReminder;"
			name=				"Component Reminder"
			attributes=			"componentReminder"

			allowPlayerDelete=	"true"
			noDebrief=			"true"
			noInProgress=		"true"
			noStats=			"true"
			>

		<Properties>
			<Data id="item"></Data>
			<Data id="componentsNeeded"></Data>
			<Data id="componentTypeList"></Data>

			<Variant id="destID">(objGetID aOwnerObj)</Variant>
			<Variant id="destName">(objGetName aOwnerObj)</Variant>
			<Variant id="destSystem">(sysGetNode)</Variant>

			<!-- Force the summary to be refreshed on every access -->

			<DynamicData id="summary">(msnTranslate gSource 'Summary)</DynamicData>

			<!-- Dynamic properties to recalculate available components -->

			<DynamicData id="availableComponents">
				(map (msn@ gSource 'componentsNeeded) theItem
					{
						item: theItem
						available: (@ (rpgCalcComponentsAvailable gPlayerShip theItem) 'availCount)
						}
					)
			</DynamicData>

			<DynamicData id="rpg.itemListDisplay">
				(map (msn@ gSource 'availableComponents) 'excludeNil theEntry
					{
						item: (@ theEntry 'item)
						disabled: (gr (itmGetCount (@ theEntry 'item)) (@ theEntry 'available))
						}
					)
			</DynamicData>
		</Properties>

		<Events>
			<!-- Only allow one active remider for each recipe -->

			<CanCreate>
				(not (map (msnFind (cat "a +unid:" gType ";")) 'excludeNil theMission
					(itmIsEqual gData (msn@ theMission 'item) 'ignoreData)
					))
			</CanCreate>

			<OnCreate>
				(block ()

					;	Store the parameters of the mission

					(msnSet@ gSource 'item (@ gData 'item))
					(msnSet@ gSource 'componentsNeeded (@ gData 'componentsNeeded))
					(msnSet@ gSource 'componentTypeList
						(map (@ gData 'componentsNeeded) theItem (itmGetType theItem))
						)
					)
			</OnCreate>
		</Events>

		<Language>
			<Text id="Name">
				(msnTranslate gSource 'descName {
					itemName:(itmGetName (msn@ gSource 'item) '(countOnly actual))
					})
			</Text>
			<Text id="Summary">
				(msnTranslate gSource 'descSummary {
					itemName: (itmGetName (msn@ gSource 'item) '(count actual))
					destName: (msn@ gSource 'destName)
					systemName: (sysGetName (msn@ gSource 'destSystem))

					componentList: (join (map (msn@ gSource 'availableComponents) theComponent
						(msnTranslate gSource 'descComponent {
							avail: (@ theComponent 'available)
							count: (itmGetCount (@ theComponent 'item))
							itemName: (itmGetName (@ theComponent 'item) '(plural actual))
							})) "\n")
					})
			</Text>

			<Text id="descName">
				[Foundry] %ItemName%
			</Text>
			<Text id="descSummary">

				Acquire components needed to create %itemName% at %destName% in %systemName%.

				%componentList%

				System: %systemName%

			</Text>
			<Text id="descComponent">[%avail% / %count%] %itemName%</Text>
			<Text id="FailureMsg"></Text>
		</Language>
	</MissionType>


	<!-- Define attribute label for items that we are looking for. -->

	<Type UNID="&unidComponentReminder;">
		<AttributeDesc>
			<ItemAttribute	label="component"	labelType="quest"	criteria="*">
				<OnShow>
					(block (
						(theType (itmGetType gItem))
						)
						(if
							(map (msnFind "a +componentReminder;") 'excludeNil theMission
								(find (msn@ theMission 'componentTypeList) theType)
								)
							True
							)
						)
				</OnShow>
			</ItemAttribute>
		</AttributeDesc>
	</Type>


<!-- GLOBALS -->
	
	<Globals>
		(block Nil
			(setq rpgCalcComponentsAvailable (lambda (theSource theComponent)
			
			;	Returns a structure containing the following fields:
			;
			;	damagedItems: A list of itemStructs in theSource that match theComponent
			;		and are damaged.
			;
			;	items: A list of itemStructs in theSource that match theComponent.
			;
			;	availCount: The total number of items that match theComponent. We can
			;		use this to compute how many items we can craft.
			;
			;	The sum of damagedItems and items is always less than or equal to
			;	the number of components needed (so that we can remove them from the
			;	source when we create an item).

				(block (
					(leftToAdd (itmGetCount theComponent))
					(availCount 0)
					(damagedComponent (itmSet@ theComponent 'damaged True))

					;	When looking for components, we ignore attributes of the item that 
					;	we don't care about.

					(compareFlags '(ignoreCharges ignoreData ignoreDisrupted ignoreEnhancements))

					;	Compute damaged items first

					(damagedItems
						(map (objGetItems theSource "*U") 'excludeNil theItem
							(switch
								(not (itmIsEqual theItem damagedComponent compareFlags))
									Nil

								;	Skip unknown items, since we don't know what they are.
								(not (itmIsKnown theItem))
									Nil

								(= leftToAdd 0)
									(block ()
										(setq availCount (+ availCount (itmGetCount theItem)))
										Nil
										)

								(block (
									(theCount (min leftToAdd (itmGetCount theItem)))
									)
									(setq availCount (+ availCount (itmGetCount theItem)))
									(setq leftToAdd (- leftToAdd theCount))

									(itmSetCount theItem theCount)
									)
								)
							)
						)

					;	Next, non-damaged items

					(undamagedItems
						(map (objGetItems theSource "*U") 'excludeNil theItem
							(switch
								(not (itmIsEqual theItem theComponent compareFlags))
									Nil

								;	Skip unknown items, since we don't know what they are.
								(not (itmIsKnown theItem))
									Nil

								(= leftToAdd 0)
									(block ()
										(setq availCount (+ availCount (itmGetCount theItem)))
										Nil
										)

								(block (
									(theCount (min leftToAdd (itmGetCount theItem)))
									)
									(setq availCount (+ availCount (itmGetCount theItem)))
									(setq leftToAdd (- leftToAdd theCount))

									(itmSetCount theItem theCount)
									)
								)
							)
						)
					)
					{
						damagedItems: damagedItems
						items: undamagedItems
						availCount: availCount
						}
					)
				))

			(setq rpgCalcCreateFromComponents (lambda (theItem theSource theFoundry)
				(block (
					(currencyUsed (objGetProperty theFoundry 'currency))
					(componentsNeeded (itmGetProperty theItem 'components))
					(itemCategory (itmGetProperty theItem 'category))
					(itemCurrency (itmGetProperty theItem 'currency))
					
					;	Compute the total price of all components
					
					(componentPrice
						(map componentsNeeded 'reduceSum theComponent
							;	For devices we assume a damaged device
							(if (itmMatches theComponent "d")
								(* (itmGetCount theComponent) (itmGetPrice (itmSet@ theComponent 'damaged True) currencyUsed))
								(* (itmGetCount theComponent) (itmGetPrice theComponent currencyUsed))
								)
							)
						)
						
					;	Mark up is based on the type of item
					
					(markUp
						(switch
							(= itemCategory 'armor)
								1.25
								
							(itmMatches theItem "d")
								1.5
								
							1.2
							)
						)
					(fullPrice (int (round (* componentPrice markUp))))
					(workPrice (- fullPrice componentPrice))
					
					;	For each required component, add up the number of items the player
					;	actually has. Note that we accept damaged items.
						
					(availableComponents
						(map componentsNeeded theComponent
							(block (
								(componentsAvail (rpgCalcComponentsAvailable theSource theComponent))
								)
								{
									item: theComponent
									available: (@ componentsAvail 'availCount)
									}
								)
							)
						)
					
					;	Figure out the maximum number of items we could afford
					;	to build, based ONLY on price (i.e., not counting
					;	components).
					
					(maxCountPrice
						(if (gr workPrice 0)
							(int (/ (objGetBalance theSource currencyUsed) workPrice))
							1000
							)
						)
						
					;	Now compute the max count based on component availability
					
					(maxCount
						(min maxCountPrice
							(map availableComponents 'reduceMin theEntry
								(int (/ (@ theEntry 'available) (itmGetCount (@ theEntry 'item))))
								)
							)
						)
					)
				
					;	Return a structure describing various aspects of the fabrication
					
					{
						item: theItem
						
						;	This is a list of items (with counts) required to fabricate.
						
						componentsNeeded: componentsNeeded
						componentsNeededDesc: (strItemList componentsNeeded 0x0108)
						
						;	These fields determine various prices
						
						componentCost: componentPrice
						currencyUsed: currencyUsed
						workCost: workPrice
						
						;	This is a list of structures describing what components the
						;	player has available. Each struct has two fields:
						;
						;	item: One of the items required (with counts)
						;	available: The number of this item the player has (including
						;		damaged.
						
						componentsAvail: availableComponents
						
						;	This is a structure suitable for an ItemListDisplay control
						
						itemListDisplay:
							(map availableComponents 'excludeNil theEntry
								{
									item: (@ theEntry 'item)
									disabled: (gr (itmGetCount (@ theEntry 'item)) (@ theEntry 'available))
									}
								)
						
						;	Maximum number of items we can fabricate
						
						maxCount: maxCount
						
						;	Missing components
						
						componentsMissing: 
							(map availableComponents 'excludeNil theEntry 
								(if (eq (@ theEntry 'available) 0)
									(@ theEntry 'item)
									)
								)
						
						componentsLacking: 
							(map availableComponents 'excludeNil theEntry 
								(if (ls (@ theEntry 'available) (itmGetCount (@ theEntry 'item)))
									(itmSetCount (@ theEntry 'item) 
										(- (itmGetCount (@ theEntry 'item)) (@ theEntry 'available))
										) 
									)
								)
						}
					)
				))
				
			(setq rpgClearComponentReminder (lambda (theSource theItem criteria)
				(enum (msnFind theSource (or criteria "a +componentReminder;")) theMission
					(if (itmIsEqual theItem (msn@ theMission 'item) 'ignoreData)
						(msnSuccess theMission)
						)
					)
				))

			(setq rpgCreateFromComponents (lambda (createCtx theSource theFoundry theCount options)
				(block (
					(itemToCreate (itmSetCount (@ createCtx 'item) (* (itmGetCount (@ createCtx 'item)) theCount)))
					(totalCost (* (@ createCtx 'workCost) theCount))
					(currencyUsed (@ createCtx 'currencyUsed))

					itemsConsumed
					)
				
					;	Consume items. NOTE: We expect our callers to have already checked
					;	to make sure there are enough items.
					
					(enum (@ createCtx 'componentsNeeded) theComponent
						(block (
							(leftToConsume (* theCount (itmGetCount theComponent)))
							(available (rpgCalcComponentsAvailable theSource (itmSetCount theComponent leftToConsume)))
							)
							
							;	Consume items
							;
							;	NOTE: rpgCalcComponentsAvailable has done all the work to figure
							;	out exactly how many items to consume.

							(enum (@ available 'damagedItems) itemToConsume
								(block ()
									(objRemoveItem theSource itemToConsume)
									(setq itemsConsumed (append itemsConsumed (list itemToConsume)))
									)
								)

							(enum (@ available 'items) itemToConsume
								(block ()
									(objRemoveItem theSource itemToConsume)
									(setq itemsConsumed (append itemsConsumed (list itemToConsume)))
									)
								)
							)
						)
						
					;	Charge player
					
					(objCharge theSource currencyUsed totalCost)
					
					;	Create the resulting item
					
					(objAddItem theSource itemToCreate)
					
					;	Loop over player missions and see if we've accomplished any of them
					
					(if (@ options 'reminderCriteria)
						(rpgClearComponentReminder theFoundry itemToCreate (@ options 'reminderCriteria))
						)
					
					;	Return result
					
					{	itemsCreated: itemToCreate
						itemsConsumed: itemsConsumed
						currencyUsed: currencyUsed
						totalCost: totalCost
						}
					)
				))
			)
	</Globals>
	
</TranscendenceModule>
